<?xml version='1.0' encoding='UTF-8' ?>

<!--Generated by XML Authority-->

<!--#DOCUMENTATION:
        Copyright (c) 2001, Fraunhofer ISST (http://www.isst.fhg.de)
        All rights reserved.

        Redistribution and use in source and binary forms, with or without
        modification, are permitted provided that the following conditions
        are met:

             Redistributions of source code must retain the above copyright
             notice, this list of conditions and the following disclaimer.
             Redistributions in binary form must reproduce the above
             copyright notice, this list of conditions and the following
             disclaimer in the documentation and/or other materials provided
             with the distribution.
             Neither the name of the Fraunhofer ISST, Germany nor the names of its
             contributors may be used to endorse or promote products derived
             from this software without specific prior written permission.
 
        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
        "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
        LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
        FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
        REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
        INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
        BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
        CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
        LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
        ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF             		-->
<!ENTITY % statement "(expr | assert | assignment | augmented_assignment | pass | del | print | return | raise | break | continue | import | global | exec)">

<!ENTITY % compound_statement "(if | while | for | try | def | class)">

<!-- DTD's do not use namespaces. xmlns:xsd = 'http://www.w3.org/2000/10/XMLSchema' -->

<!--#DOCUMENTATION:This element is the frame of the module/program. The atttribute 'name' defines the default name 
of the target file. The prefix ".py" will be appended.
			
			-->
<!ELEMENT python (%statement; | %compound_statement; | doc)*>

<!ATTLIST python  name CDATA  #IMPLIED >
<!--#DOCUMENTATION:If you use the attribute 'from' all identifier will be unqualified imported, if there are no 'identifier' declared. If you include
'import_identifier' elements only those identifiers are unqualified imported. If you include 'module_identifier' elements, 
the identifier of the  modules will be complete, qualified imported. The attribute 'as' allows you to rename an imported 
module name.
			
			-->
<!ELEMENT import (import_identifier* | module_identifier+)>

<!ATTLIST import  from CDATA  #IMPLIED
                   as   CDATA  #IMPLIED >
<!ELEMENT identifier (#PCDATA)>

<!ATTLIST identifier  e-dtype NMTOKEN  #FIXED 'string' >
<!ELEMENT pass EMPTY>

<!--#DOCUMENTATION:The value of the expressions will be assigned to the variables in the targets. Python allows multiple assignments, so there could be more than one target.-->
<!ELEMENT assignment (target+ , expr+)>

<!ELEMENT expr (#PCDATA)>

<!ATTLIST expr  e-dtype NMTOKEN  #FIXED 'CDATA' >
<!--#DOCUMENTATION:This element defines the delete function, which destroys the declared variables.-->
<!ELEMENT del (identifier+)>

<!--#DOCUMENTATION:The 'expr' elements will be printed to the standard output. If you set the optional attribute 'file', the output 
will be output to this object.
			
			-->
<!ELEMENT print (expr*)>

<!ATTLIST print  file CDATA  #IMPLIED >
<!--#DOCUMENTATION:The element exec evaluate an expression given in the text part, which will be executed in the context specified by the attributes 'local' and 'global'.-->
<!ELEMENT exec (#PCDATA)>

<!ATTLIST exec  local   CDATA    #IMPLIED
                 global  CDATA    #IMPLIED
                 e-dtype NMTOKEN  #FIXED 'CDATA' >
<!--#DOCUMENTATION:This element declares one parameter. The attribute 'name' is the name of the parameter where the text defines the default value. A parameter can be a variable array of values if it is marked by the element 'vararg'. If a parameter is marked by the element 'dictionary' the parameter is a dictionary with the parameters.-->
<!ELEMENT parameter (vararg? , dictionary?)>

<!ATTLIST parameter  name    CDATA  #IMPLIED
                      default CDATA  #IMPLIED >
<!--#DOCUMENTATION:The element 'if' is the frame for the condional statement. There could be multiple conditions ('elif').-->
<!ELEMENT if (condition+ , else?)>

<!--#DOCUMENTATION:If the value of the 'expr' evaluates to true, the statements will be executed.-->
<!ELEMENT condition (%statement; | %compound_statement;)*>

<!ATTLIST condition  expr CDATA  #IMPLIED >
<!ELEMENT else (%statement; | %compound_statement;)*>

<!--#DOCUMENTATION:The element 'while' defines a loop. The code block will be executed as long as the condition is met. 
If the condition do net met the code block of the element 'else' will be executed.
			
			-->
<!ELEMENT while ((%statement; | %compound_statement;)* , else?)>

<!ATTLIST while  condition CDATA  #IMPLIED >
<!--#DOCUMENTATION:The element 'for' defines a programming loop over all values of the attribute 'in', which is a list. The attribute 
'target' is the name of the varaible containing the actual value of the list element. The element 'else' will be 
executed, when there are no further list elements available.
			
			-->
<!ELEMENT for ((%statement; | %compound_statement;)* , else?)>

<!ATTLIST for  target CDATA  #IMPLIED
                in     CDATA  #IMPLIED >
<!ELEMENT break EMPTY>

<!ELEMENT continue EMPTY>

<!--#DOCUMENTATION:This element returns the values evaluated from the elements 'expr'.-->
<!ELEMENT return (expr*)>

<!--#DOCUMENTATION:The text part describes the assertion. The attribute 'condition' can be tested to check if the assertion will be tested.-->
<!ELEMENT assert (#PCDATA)>

<!ATTLIST assert  condition CDATA    #IMPLIED
                   e-dtype   NMTOKEN  #FIXED 'CDATA' >
<!--#DOCUMENTATION:If the code block issues an exception, the exception can be catched by the elements 'except'.-->
<!ELEMENT try ((%statement; | %compound_statement;)* , ((except+ , else?) | (finally)))>

<!--#DOCUMENTATION:The element 'except' handles an exception. The optional attribute 'expr' will be matched with the exception condition. The optional attribute 'target' contains the object reference of the raising object and will be matched, too.-->
<!ELEMENT except (%statement; | %compound_statement;)*>

<!ATTLIST except  expr   CDATA  #IMPLIED
                   target CDATA  #IMPLIED >
<!ELEMENT finally (%statement; | %compound_statement;)*>

<!ELEMENT raise (#PCDATA)>

<!ATTLIST raise  value     CDATA    #IMPLIED
                  traceback CDATA    #IMPLIED
                  e-dtype   NMTOKEN  #FIXED 'CDATA' >
<!--#DOCUMENTATION:The element 'global' declares the given variables to be global variables.-->
<!ELEMENT global (identifier+)>

<!--#DOCUMENTATION:This element defines a python class. The class inherit from the superclasses. The attribute 'name' defines the name of the class.-->
<!ELEMENT class (superclass* , (%statement; | %compound_statement; | doc)*)>

<!ATTLIST class  name CDATA  #IMPLIED >
<!--#DOCUMENTATION:This element defines a function. The attribute 'name' is the name of the function. The parameters of the function are declared by the element parameter.-->
<!ELEMENT def (parameter* , (%statement; | %compound_statement; | doc)*)>

<!ATTLIST def  name CDATA  #IMPLIED >
<!ELEMENT vararg EMPTY>

<!ELEMENT dictionary EMPTY>

<!ELEMENT superclass (#PCDATA)>

<!ATTLIST superclass  e-dtype NMTOKEN  #FIXED 'string' >
<!--#DOCUMENTATION:The element 'doc' includes a documentation string ('__doc__').-->
<!ELEMENT doc (#PCDATA)>

<!ATTLIST doc  e-dtype NMTOKEN  #FIXED 'CDATA' >
<!--#DOCUMENTATION:The attribute 'operator' names the binary operation, which assigns a new value calculated from the expressions to the variables.-->
<!ELEMENT augmented_assignment (identifier+ , expr+)>

<!ATTLIST augmented_assignment  operator CDATA  #IMPLIED >
<!ELEMENT target (identifier+)>

<!ELEMENT import_identifier (#PCDATA)>

<!ATTLIST import_identifier  as      CDATA    #IMPLIED
                              e-dtype NMTOKEN  #FIXED 'string' >
<!ELEMENT module_identifier (#PCDATA)>

<!ATTLIST module_identifier  as      CDATA    #IMPLIED
                              e-dtype NMTOKEN  #FIXED 'string' >
