<?xml version = "1.0" encoding = "UTF-8"?>
<!--Generated by XML Authority. Conforms to w3c http://www.w3.org/2000/10/XMLSchema-->
<schema xmlns = "http://www.w3.org/2000/10/XMLSchema"
	 targetNamespace = "http://ftp.berlios.de/xmlpy/py.xsd"
	 xmlns:py = "http://ftp.berlios.de/xmlpy/py.xsd"
	 xmlns:xsd = "http://www.w3.org/2000/10/XMLSchema"
	 version = "0.1"
	 elementFormDefault = "unqualified"
	 attributeFormDefault = "unqualified">
	<annotation>
		<documentation>
        Copyright (c) 2001, Fraunhofer ISST (http://www.isst.fhg.de)
        All rights reserved.

        Redistribution and use in source and binary forms, with or without
        modification, are permitted provided that the following conditions
        are met:

             Redistributions of source code must retain the above copyright
             notice, this list of conditions and the following disclaimer.
             Redistributions in binary form must reproduce the above
             copyright notice, this list of conditions and the following
             disclaimer in the documentation and/or other materials provided
             with the distribution.
             Neither the name of the Fraunhofer ISST, Germany nor the names of its
             contributors may be used to endorse or promote products derived
             from this software without specific prior written permission.
 
        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
        "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
        LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
        FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
        REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
        INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
        BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
        CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
        LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
        ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF             		
		</documentation>
	</annotation>
	<group name = "statement">
		<choice>
			<element ref = "py:expr"/>
			<element ref = "py:assert"/>
			<element ref = "py:assignment"/>
			<element ref = "py:augmented_assignment"/>
			<element ref = "py:pass"/>
			<element ref = "py:del"/>
			<element ref = "py:print"/>
			<element ref = "py:return"/>
			<element ref = "py:raise"/>
			<element ref = "py:break"/>
			<element ref = "py:continue"/>
			<element ref = "py:import"/>
			<element ref = "py:global"/>
			<element ref = "py:exec"/>
		</choice>
	</group>
	<group name = "compound_statement">
		<choice>
			<element ref = "py:if"/>
			<element ref = "py:while"/>
			<element ref = "py:for"/>
			<element ref = "py:try"/>
			<element ref = "py:def"/>
			<element ref = "py:class"/>
		</choice>
	</group>
	<element name = "python">
		<annotation>
			<documentation>This element is the frame of the module/program. The atttribute 'name' defines the default name 
of the target file. The prefix ".py" will be appended.
			
			
			</documentation>
		</annotation>
		<complexType>
			<choice minOccurs = "0" maxOccurs = "unbounded">
				<group ref = "py:statement"/>
				<group ref = "py:compound_statement"/>
				<element ref = "py:doc"/>
			</choice>
			<attribute name = "name" type = "string"/>
		</complexType>
	</element>
	<element name = "import">
		<annotation>
			<documentation>If you use the attribute 'from' all identifier will be unqualified imported, if there are no 'identifier' declared. If you include
'import_identifier' elements only those identifiers are unqualified imported. If you include 'module_identifier' elements, 
the identifier of the  modules will be complete, qualified imported. The attribute 'as' allows you to rename an imported 
module name.
			
			
			</documentation>
		</annotation>
		<complexType>
			<choice>
				<element ref = "py:import_identifier" minOccurs = "0" maxOccurs = "unbounded"/>
				<element ref = "py:module_identifier" maxOccurs = "unbounded"/>
			</choice>
			<attribute name = "from" type = "string"/>
			<attribute name = "as" type = "string"/>
		</complexType>
	</element>
	<element name = "identifier" type = "string"/>
	<element name = "pass">
		<complexType/>
	</element>
	<element name = "assignment">
		<annotation>
			<documentation>The value of the expressions will be assigned to the variables in the targets. Python allows multiple assignments, so there could be more than one target.</documentation>
		</annotation>
		<complexType>
			<sequence>
				<element ref = "py:target" maxOccurs = "unbounded"/>
				<element ref = "py:expr" maxOccurs = "unbounded"/>
			</sequence>
		</complexType>
	</element>
	<element name = "expr" type = "CDATA"/>
	<element name = "del">
		<annotation>
			<documentation>This element defines the delete function, which destroys the declared variables.</documentation>
		</annotation>
		<complexType>
			<sequence>
				<element ref = "py:identifier" maxOccurs = "unbounded"/>
			</sequence>
		</complexType>
	</element>
	<element name = "print">
		<annotation>
			<documentation>The 'expr' elements will be printed to the standard output. If you set the optional attribute 'file', the output 
will be output to this object.
			
			
			</documentation>
		</annotation>
		<complexType>
			<sequence>
				<element ref = "py:expr" minOccurs = "0" maxOccurs = "unbounded"/>
			</sequence>
			<attribute name = "file" type = "string"/>
		</complexType>
	</element>
	<element name = "exec">
		<annotation>
			<documentation>The element exec evaluate an expression given in the text part, which will be executed in the context specified by the attributes 'local' and 'global'.</documentation>
		</annotation>
		<complexType>
			<simpleContent>
				<extension base = "CDATA">
					<attribute name = "local" type = "string"/>
					<attribute name = "global" type = "string"/>
				</extension>
			</simpleContent>
		</complexType>
	</element>
	<element name = "parameter">
		<annotation>
			<documentation>This element declares one parameter. The attribute 'name' is the name of the parameter where the text defines the default value. A parameter can be a variable array of values if it is marked by the element 'vararg'. If a parameter is marked by the element 'dictionary' the parameter is a dictionary with the parameters.</documentation>
		</annotation>
		<complexType>
			<sequence>
				<element ref = "py:vararg" minOccurs = "0"/>
				<element ref = "py:dictionary" minOccurs = "0"/>
			</sequence>
			<attribute name = "name" type = "string"/>
			<attribute name = "default" type = "string"/>
		</complexType>
	</element>
	<element name = "if">
		<annotation>
			<documentation>The element 'if' is the frame for the condional statement. There could be multiple conditions ('elif').</documentation>
		</annotation>
		<complexType>
			<sequence>
				<element ref = "py:condition" maxOccurs = "unbounded"/>
				<element ref = "py:else" minOccurs = "0"/>
			</sequence>
		</complexType>
	</element>
	<element name = "condition">
		<annotation>
			<documentation>If the value of the 'expr' evaluates to true, the statements will be executed.</documentation>
		</annotation>
		<complexType>
			<choice minOccurs = "0" maxOccurs = "unbounded">
				<group ref = "py:statement"/>
				<group ref = "py:compound_statement"/>
			</choice>
			<attribute name = "expr" type = "string"/>
		</complexType>
	</element>
	<element name = "else">
		<complexType>
			<choice minOccurs = "0" maxOccurs = "unbounded">
				<group ref = "py:statement"/>
				<group ref = "py:compound_statement"/>
			</choice>
		</complexType>
	</element>
	<element name = "while">
		<annotation>
			<documentation>The element 'while' defines a loop. The code block will be executed as long as the condition is met. 
If the condition do net met the code block of the element 'else' will be executed.
			
			
			</documentation>
		</annotation>
		<complexType>
			<sequence>
				<choice minOccurs = "0" maxOccurs = "unbounded">
					<group ref = "py:statement"/>
					<group ref = "py:compound_statement"/>
				</choice>
				<element ref = "py:else" minOccurs = "0"/>
			</sequence>
			<attribute name = "condition" type = "string"/>
		</complexType>
	</element>
	<element name = "for">
		<annotation>
			<documentation>The element 'for' defines a programming loop over all values of the attribute 'in', which is a list. The attribute 
'target' is the name of the varaible containing the actual value of the list element. The element 'else' will be 
executed, when there are no further list elements available.
			
			
			</documentation>
		</annotation>
		<complexType>
			<sequence>
				<choice minOccurs = "0" maxOccurs = "unbounded">
					<group ref = "py:statement"/>
					<group ref = "py:compound_statement"/>
				</choice>
				<element ref = "py:else" minOccurs = "0"/>
			</sequence>
			<attribute name = "target" type = "string"/>
			<attribute name = "in" type = "string"/>
		</complexType>
	</element>
	<element name = "break">
		<complexType/>
	</element>
	<element name = "continue">
		<complexType/>
	</element>
	<element name = "return">
		<annotation>
			<documentation>This element returns the values evaluated from the elements 'expr'.</documentation>
		</annotation>
		<complexType>
			<sequence>
				<element ref = "py:expr" minOccurs = "0" maxOccurs = "unbounded"/>
			</sequence>
		</complexType>
	</element>
	<element name = "assert">
		<annotation>
			<documentation>The text part describes the assertion. The attribute 'condition' can be tested to check if the assertion will be tested.</documentation>
		</annotation>
		<complexType>
			<simpleContent>
				<extension base = "CDATA">
					<attribute name = "condition" type = "string"/>
				</extension>
			</simpleContent>
		</complexType>
	</element>
	<element name = "try">
		<annotation>
			<documentation>If the code block issues an exception, the exception can be catched by the elements 'except'.</documentation>
		</annotation>
		<complexType>
			<sequence>
				<choice minOccurs = "0" maxOccurs = "unbounded">
					<group ref = "py:statement"/>
					<group ref = "py:compound_statement"/>
				</choice>
				<choice>
					<sequence>
						<element ref = "py:except" maxOccurs = "unbounded"/>
						<element ref = "py:else" minOccurs = "0"/>
					</sequence>
					<sequence>
						<element ref = "py:finally"/>
					</sequence>
				</choice>
			</sequence>
		</complexType>
	</element>
	<element name = "except">
		<annotation>
			<documentation>The element 'except' handles an exception. The optional attribute 'expr' will be matched with the exception condition. The optional attribute 'target' contains the object reference of the raising object and will be matched, too.</documentation>
		</annotation>
		<complexType>
			<choice minOccurs = "0" maxOccurs = "unbounded">
				<group ref = "py:statement"/>
				<group ref = "py:compound_statement"/>
			</choice>
			<attribute name = "expr" type = "string"/>
			<attribute name = "target" type = "string"/>
		</complexType>
	</element>
	<element name = "finally">
		<complexType>
			<choice minOccurs = "0" maxOccurs = "unbounded">
				<group ref = "py:statement"/>
				<group ref = "py:compound_statement"/>
			</choice>
		</complexType>
	</element>
	<element name = "raise">
		<complexType>
			<simpleContent>
				<extension base = "CDATA">
					<attribute name = "value" type = "string"/>
					<attribute name = "traceback" type = "string"/>
				</extension>
			</simpleContent>
		</complexType>
	</element>
	<element name = "global">
		<annotation>
			<documentation>The element 'global' declares the given variables to be global variables.</documentation>
		</annotation>
		<complexType>
			<sequence>
				<element ref = "py:identifier" maxOccurs = "unbounded"/>
			</sequence>
		</complexType>
	</element>
	<element name = "class">
		<annotation>
			<documentation>This element defines a python class. The class inherit from the superclasses. The attribute 'name' defines the name of the class.</documentation>
		</annotation>
		<complexType>
			<sequence>
				<element ref = "py:superclass" minOccurs = "0" maxOccurs = "unbounded"/>
				<choice minOccurs = "0" maxOccurs = "unbounded">
					<group ref = "py:statement"/>
					<group ref = "py:compound_statement"/>
					<element ref = "py:doc"/>
				</choice>
			</sequence>
			<attribute name = "name" type = "string"/>
		</complexType>
	</element>
	<element name = "def">
		<annotation>
			<documentation>This element defines a function. The attribute 'name' is the name of the function. The parameters of the function are declared by the element parameter.</documentation>
		</annotation>
		<complexType>
			<sequence>
				<element ref = "py:parameter" minOccurs = "0" maxOccurs = "unbounded"/>
				<choice minOccurs = "0" maxOccurs = "unbounded">
					<group ref = "py:statement"/>
					<group ref = "py:compound_statement"/>
					<element ref = "py:doc"/>
				</choice>
			</sequence>
			<attribute name = "name" type = "string"/>
		</complexType>
	</element>
	<element name = "vararg">
		<complexType/>
	</element>
	<element name = "dictionary">
		<complexType/>
	</element>
	<element name = "superclass" type = "string"/>
	<element name = "doc" type = "CDATA">
		<annotation>
			<documentation>The element 'doc' includes a documentation string ('__doc__').</documentation>
		</annotation>
	</element>
	<element name = "augmented_assignment">
		<annotation>
			<documentation>The attribute 'operator' names the binary operation, which assigns a new value calculated from the expressions to the variables.</documentation>
		</annotation>
		<complexType>
			<sequence>
				<element ref = "py:identifier" maxOccurs = "unbounded"/>
				<element ref = "py:expr" maxOccurs = "unbounded"/>
			</sequence>
			<attribute name = "operator" type = "string"/>
		</complexType>
	</element>
	<element name = "target">
		<complexType>
			<sequence>
				<element ref = "py:identifier" maxOccurs = "unbounded"/>
			</sequence>
		</complexType>
	</element>
	<element name = "import_identifier">
		<complexType>
			<simpleContent>
				<extension base = "string">
					<attribute name = "as" type = "string"/>
				</extension>
			</simpleContent>
		</complexType>
	</element>
	<element name = "module_identifier">
		<complexType>
			<simpleContent>
				<extension base = "string">
					<attribute name = "as" type = "string"/>
				</extension>
			</simpleContent>
		</complexType>
	</element>
</schema>